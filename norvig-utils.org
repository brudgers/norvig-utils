#+TITLE: Norvig Utilities
#+OPTIONS: num:nil ^:{}

Various utility functions from *Paradigms of Aritifical Intelligence: case studies in Common Lisp*

Part of the exercise for =norvig-utils.org= is to learn package and system managment in Common Lisp. As I worked through Eliza, it was becoming a bit of a problem in terms of keeping a =slime-repl= open in Emacs.

#+Begin_SRC lisp :tangle norvig-utils.lisp :noweb tangle
  ;;; This file autogenerated from norvig-utils.org

  <<package-norvig-utils>>

  <<eliza>>

  <<general-problem-solver>>
#+END_SRC
* Utilities
** System
#+NAME: system-norvig-utils
#+BEGIN_SRC lisp :tangle norvig-utils.asd
  (defpackage :norvig-utils
    (:use :common-lisp)
    (;;; from eliza
     :export :get-bindings
             :binding-val
             :lookup
             :extend-bindings
     ;;; from general-problem-solver
             :member-equal
             :find-all
             :find-all-if
             :starts-with
             :mappend))

  (in-package :norvig-utils)

  (defsystem norvig-utils
    :serial t
    :components ((:file "norvig-utils")))
#+END_SRC
** norvig-utils
#+NAME: norvig-utils
#+BEGIN_SRC lisp :noweb tangle :tangle norvig-utils.lisp
  (in-package :norvig-utils)

  <<eliza>>

  <<general-problem-solver>>
#+END_SRC
** Eliza
 Abstractions over association lists.
 + get-bindings
 + binding-val
 + lookup
 + extend-bindings
 #+NAME: eliza
 #+BEGIN_SRC lisp
   ;;; Functions that abstract over association lists

   (defun get-bindings (var bindings)
     "Find a (variable . value) pair in a binding list."
     (assoc var bindings))

   (defun binding-val (binding)
     "Get the value part of a single binding."
     (cdr binding))

   (defun lookup (var bindings)
     "Get the value part (for var) from a binding list."
     (binding-val (get-bindings var bindings)))

   (defun extend-bindings (var val bindings)
     "Add a (var . value) pair to a binding list."
     (cons (cons var val) bindings))
 #+END_SRC

** General Problem Solver
 Functions:
 + member-equal
 + find-all
 + find-all-if
 + starts-with
 + mappend
 #+NAME: general-problem-solver
 #+BEGIN_SRC lisp
   (defun member-equal (item list)
     "Test for membership in a list as set using equal."
     (member item list :test #'equal))

   (setf (symbol-function 'find-all-if) #'remove-if-not)

   (defun find-all (item sequence &rest keyword-args
                    &key (test #'eql)
                      test-not
                      &allow-other-keys)
     "Find all those elements of sequence that match item.
      according to the keywords. Does not alter sequence"
     (if test-not
         (apply #'remove item sequence
                :test-not (complement test-not) keyword-args)
         (apply #'remove item sequence
                :test (complement test) keyword-args)))

   (defun starts-with (list x)
     "Is this a list whose first element is x?"
     (and (consp list)
          (eql (first list) x)))

   (defun mappend (fn the-list)
     "Apply function to each element of the list and append the results."
     (apply #'append (mapcar fn the-list)))
 #+END_SRC
* Debugger
** System
#+NAME: debugger-system
#+BEGIN_SRC lisp :tangle norvig-debugger.asd
  (defpackage :norvig-debugger
    (:use :common-lisp)
    (:export :*dbg-ids*
             :dbg
             :start-debug
             :undebug
             :dbg-indent))

  (in-package :norvig-debugger)

  (defsystem norvig-debugger
    :serial t
    :components ((:file "norvig-debugger")))
#+END_SRC
** Functions
The debugger is built as part of the General Problem Solver.
#+BEGIN_SRC lisp :tangle norvig-debugger.lisp
  (in-package :norvig-debugger)

  (defvar *dbg-ids* nil
    "Identifiers used by dbg")

  (defun dbg (id format-string &rest args)
    "Print debugging information if (DEBUG-ID) has been specified."
    (when (member id *dbg-ids*)
      (fresh-line *debug-io*)
      (apply #'format *debug-io* format-string args)))

  ;;; Using start-debugging because 'debug' reserved in SBCL
  (defun start-debug (&rest ids)
    "Start dbg output on the given ids."
    (setf *dbg-ids* (union ids *dbg-ids*)))

  (defun undebug (&rest ids)
    "Stop dbg on the ids. With no ids, stop debugging altogether."
    (setf *dbg-ids* (if (null ids) nil
                      (set-difference *dbg-ids* ids))))

  (defun dbg-indent (id indent format-string &rest args)
    "Print indented debugging info if (DEBUG ID) has been specified."
    (when (member id *dbg-ids*)
      (fresh-line *debug-io*)
      (dotimes (i indent) (princ "   " *debug-io*))
      (apply #'format *debug-io* format-string args)))
#+END_SRC
